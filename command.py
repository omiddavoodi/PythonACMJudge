import subprocess, threading
import os
#import socket

class Command(object): #this class organizes the "judging" action and returns the result
    # [TODO]: Too much things to list here, but most importantly, some checks for the files
    # (so that they exist) and checking the code for any possible malovenant parts
    # before running it (And restricting the libraries that could be opened to only "math")
    def __init__(self, cmd, n):
        self.cmd = cmd
        self.process = None
        self.result = 0
        self.n = n
        self.errortext = ""

    def run(self, timeout, problem):

        # this function gets done in a thread
        def target():
            rfn = "result" + str(self.n) + ".txt" # rfn: 'result file name'
            efn = "error" + str(self.n) + ".txt" # efn: 'error file name'

            # Check if the file exists
            problemfilepath = "problems/" + problem + ".in"
            
            if (not os.path.isfile(problemfilepath)):
                self.result = 0 # For them, it should be unknown error
            else:
                # Open the input file of the problem to send it to the file using standard OS input method
                f = open (problemfilepath)
                
                # Open the output and error output files for the reason stated above
                o = open (rfn, mode='w')
                er = open (efn, mode='w')

                # Run the program, send the input and get the output and error files
                self.process = subprocess.Popen(self.cmd,stdin=f, stdout=o,stderr=er)
                self.process.communicate()

                # We need to close these before we could read them
                o.close()
                er.close()

                # Open them again (This time to read)
                res = open(rfn)
                perr = open(efn)

                # Open the standard output of the problem so that we can compare the
                # Output of the recieved code with it
                out = open("problems/" + problem + ".out")

                # If they were similar, the code is accepted
                if res.read() == out.read():
                    self.result = 1
                # If not, something could have happened
                else:
                    # Like some errors
                    txterror = perr.read()

                    if (txterror == ""): # If not, the it was simply wrong answer
                        self.result = 2
                    else: # Otherwise, let the poor guy know what he had done wrong
                        self.result = 3
                        self.errortext = txterror
                # OK, close all of the opened files
                res.close()
                out.close()
                perr.close()

                # And remove those that were generated by the code (result and error .txt)
                os.remove(rfn)
                os.remove(efn)

        # OK, start a thread for the function above
        thread = threading.Thread(target=target)
        thread.start()

        # We need it to run for a specific ammount of time
        thread.join(timeout)

        if thread.is_alive(): # If that time ran, well, terminate the program
            self.process.terminate()
            thread.join()

            # And set the result code to 4 (means timeout)
            self.result = 4

        # Now after all these, return both the returncode and errortext
        return [self.result, self.errortext]
